## 第十章：面向对象（进阶）



### **类变量**：

类变量也叫静态变量 / 静态属性，是该类的所有对象**共享的变量**，任何一个该类的对象去访问它时，取到的都是**相同的值**，任何一个该类对象去修改它时，**修改的也是同一个变量**。

说明：类变量是随着类的加载而创建的

定义语法：
1.访问修饰符	static  	数据类型 	变量名;



**类变量于普通属性的区别：**
类变量是该类的所有对象共享的，而实例变量是每个对象独享的

实例变量不能通过	类名.类变量名	方式访问

类变量时在类加载时就初始化了，只要类加载了，就可以使用类变量

---



## **类方法**

也叫静态方法

形式：	访问修饰符 static 数据返回类型	方法名() {}

类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：
**类方法中无this的参数**
**普通方法中隐含this的参数**

类方法可以通过类名调用，也可以通过对象名调用 /	普通方法不行

---

## **代码块**

1.**static**代码块也叫**静态代码块**，作用就是对类进行初始化，而且它**随着类的加载而执行**，并且只执行一次
如果是**普通代码块**，每创建一个对象，就执行。

2.类什么时候被加载【重要！】
a.创建对象实例的时候（new）
b.创建子类对象实例，父类也会被加载
c.使用类的静态成员时(静态属性，静态方法）

3.**普通代码块**，在创建对象实例时，会被隐式调用。
被创建一次，就会调用一次。
如果只是使用类的静态成员时，普通代码并不会执行

4.在创建一个对象时，在一个类的调用顺序是：
-调用静态代码块和静态属性初始化（静态代码块和静态变量优先级一样，按它们定义的顺序调用)
-调用普通代码块和普通属性初始化（代码块和变量优先级一样，按它们定义的顺序调用)
-调用构造方法

5.构造器的最前面其实隐含了super() 和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于构造器和普通代码的

6.创建一个子类对象（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法如下：
**父类静态**代码块和静态属性
**子类静态**代码块和静态属性
**父类普通**代码块和普通属性初始化
**父类构造方法**
**子类普通**代码和普通属性初始化
**子类构造器**

7.静态代码块只能调用静态成员，普通代码块可以调用任意成员



## **单例设计模式**

单例模式应用实例：(饿汉式)	可能造成创造了对象但是未使用
1.构造器私有化
2.类的内部创建对象：

```java
private static GirlFriend gf = new GirlFriend("小红红");
```

3.向外暴露一个静态的公共办法：	

```java
public static GirlFriend getInstance() {    
    return gf;
}
```

4.代码实现

懒汉式：
1.构造器私有化
2.类的内部创建对象	例：

```java
private static Cat cat;
```

3.向外暴露一个静态的公共方法：	

```java
public static Cat getInstance() {    
	if (cat == null) {           
    	 cat = new Cat("小可爱");    
  	}    
    return cat;
}
```

4.代码实现

---



## Final关键字

1.当不希望类被继承时，可以使用final修饰
2.当不希望父类的某个方法被子类覆盖/重写
3.当不希望某个属性被修改
4.当不希望一个局部变量被修改

---

**final修饰的属性又叫常量，一般用XX_XX_XX来命名**

**含有final关键字修饰的属性在定义时可以在如下几个位置赋值：**
1.public final double TAX_RATE = 0.08;
2.在构造器中
3.在代码块中

**如果final修饰的是静态的，则初始化位置只能是：**
1.定义时 
2.静态代码块，不能在构造器中赋值

**final类不能继承，但是可以实例化对象**

**如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承**

**final不能修饰构造方法**

**final和static往往搭配使用，效率更高，不会导致类加载。（因此不会调用静态方法块）底层编译器做了优化处理**

---

## **抽象类**

当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类

用abstract关键字来修饰一个方法时，这个方法就是抽象方法，格式：
**访问修饰符 abstract 返回类型 方法名（参数列表）**

注意事项：

**1.抽象类不能被实例化**

**2.抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法**

**3.一旦类包含了abstract方法，则这个类必须声明为abstract**

**4.abstract只能修饰类和方法，不能修饰属性和其他的**

**5.抽象类可以有任何成员**

**6.抽象方法不能有主体，即不能实现**

**7.如果一个类继承了抽象类，则它必须实现（重写）抽象类的所有抽象方法，除非它自己也声明为abstract类**

**8.抽象方法不能使用private 	final	static来修饰，因为这些关键字都和重写相违背。**

---



## 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

**语法：**
**interface 接口名 {**
	**//属性**
	**//方法(1.抽象方法	2.默认实现方法（default）	3.静态方法)**
**}**

### 细节：

1.接口不能被实例化
2.接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰
3.一个普通类实现接口就一定要将接口所有的方法实现 
（可以将光标放在接口名上，alt + enter 实现所有方法）
**4.抽象类实现接口，可以不用实现方法**
**5.一个类同时可以实现多个接口**
**6.接口中的属性，只能是final， 而且是 public static final  修饰符**
7.接口中访问属性	接口名.属性名
**8.接口不能继承其他类，但是可以继承其他接口**
9.接口的修饰符，只能是 public 或者是默认



### 继承与接口的区别：

**1.当子类继承了父类，就自动的拥有了父类的功能**
**2.如果子类需要扩展功能，可以通过实现接口方式扩展**
**3.可以理解 实现接口 是 对JAVA 单继承机制的一种补充**



### 接口的多态特性

1.多态参数( 可以接收实现了 UsbInterface 接口的类的对象实例 )
2.**接口类型的变量** 可以指向 实现了接口的类 的 对象实例

```java
public class InterfacePolyParameter {
    public static void main(String[] args) {
        //接口多态的体现
        //接口类型的变量 if01 可以指向 实现了IF接口的类的对象实例
        IF if01 = new Monster();
        if01 = new Car();
        
        //继承实现的多态
        AAA a = new BBB();
        a = new CCC();
    }
}

interface IF {}
class Monster implements IF {
    
}
class Car implements IF {}
class AAA{}
class BBB extends AAA {}
class CCC extends AAA {}
```

**3.多态数组**

```java
public class InterfacePolyArr {
    public static void main(String[] args) {

        Usb[] usbs = new Usb[2];
        usbs[0] = new Phone_();
        usbs[1] = new Camera_();
        for (int i = 0; i < usbs.length; i++) {
            usbs[i].work();     //动态绑定
            if (usbs[i] instanceof Phone_) {
                ((Phone_) usbs[i]).call();
            }
        }
    }
}

interface Usb{
    void work();
}

class Phone_ implements  Usb {
    public void call() {
        System.out.println("手机可以打电话...");
    }

    @Override
    public void work() {
        System.out.println("收集工作中");
    }
}

class Camera_ implements Usb {
    @Override
    public void work() {
        System.out.println("相机工作中");
    }
}
```

**4.多态实例**

```java
public class InterfacePloyPass {
    public static void main(String[] args) {
        //接口类型的变量可以指向，该接口类的对象实例
        IG_ ig = new Teacher_();
        //多态传递
        IH_ ih = new Teacher_();
    }
}

interface IH_ {
    void hi();
}
interface IG_ extends IH_{}
class Teacher_ implements IG_ {
    @Override
    public void hi() {
        System.out.println("new IH");
    }
}
```



---

## 内部类

基本介绍：
一个类的内部类又完整嵌套了另一个类结构，称为内部类。
嵌套其他类的类成为外部类(outer class)。是我们类的第五大成员**【属性，方法，构造器，代码块，内部类】**
**最大特点：可以直接访问私有属性**

基本语法：

```java
class Outer {		//外部类
    class Inner {		//内部类
        
    }
}
class Other {
    	//外部其他类
}
```



**定义在外部类局部位置上（比如方法内）：**
1.局部内部类（有类名）
2.匿名内部类（没有类名）

**定义在外部类的成员位置上：**
1.成员内部类 （没用static修饰）
2.静态内部类	（使用static修饰）

----



## 内部类

### 局部内部类

说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名
1.可以直接访问外部类的所有成员，包含私有的

2.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符修饰的。但是可以使用final修饰，因为局部变量也可以使用final

3.作用域：仅仅在定义它的方法或方法块中

4.外部类访问--->局部内部类的成员：
访问方式：创建对象，再访问

5.外部其他类 不能直接 访问 局部内部类

6.如果外部类和局部内部类的成员重名时，默认遵循就近原则；如果想访问外部类的成员，则可以使用

**（外部类名.this.成员）去访问**

---

### 匿名内部类【重要！！！】

1.本质是类	2.内部类	3.该类没有名字	4.同时还是一个对象

说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且**没有类名**
1.语法：

```java
new 类或接口（参数列表） {
    类体
}；
```

**jdk底层在创建匿名内部类，立即马上就创建类实例，并且把地址返回给给分配的类名**



### 匿名内部类的使用：

1.匿名内部类的语法比较奇特，因为匿名内部类既是一个类定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。

```java
new A() {
    @Override
    public void cry() {
        System.out.println("hello~");
    }
}.cry()
```

```java
A a = new A() {
    @Override
    public void cry() {
        System.out.println("Hello~");
    }
};
a.cry();
```

2.可以直接访问外部类的所有成员，包含私有的

3.不能添加访问修饰符，因为它的地位就是一个局部变量

4.作用域：仅仅定义它的方法或代码块中

5.匿名内部类--->访问--->外部类成员 【直接访问】

6.外部其他类不能访问匿名内部类

7.如果外部类和匿名内部类的成员重名时，匿名内部类访问的话。默认遵循就近原则，如果想访问外部类的成员，则可以使用 **【外部类名.this.成员】**去访问



### 实践：

1.当作实参直接传递，简洁高效 (适用于仅调用一次的情况，方面修改)

```java
public class InnerClassExercise01 {
    public static void main(String[] args) {
        f1(new IL() {
            @Override
            public void show() {
                System.out.println("这是一幅名画....");
            }
        });
    }
    public static void f1(IL il) {
        il.show();
    }
}

interface IL {
    void show();
}
```

---



## 成员内部类：

1.可以直接访问外部类的所有成员，包含私有的

2.可以添加任意访问修饰符**（public \ protected \ 默认 \ private )**，因为它也是一个**成员**

3.作用域: 和外部类的其他成员一样，为整个类体；在外部类成员方法中创建成员内部类对象，再调用方法。

4.成员内部类 可以直接调用外部类的所有成员	**包括私有的**

5.外部类--访问--->成员内部类（说明）
访问方式：创建对象，再访问

6.外部其他类 -- 访问 ---> 成员内部类
有两种方法：
1.直接创建 例：Outer08.Inner08 inner08 = outer08.new Inner08();
2.写一个方法，返回这个类的对象

7.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用**（外部类名.this.成员）**去访问

---

## 静态内部类

说明：定义在外部类的成员位置，并且有static修饰

1.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员

2.可以添加任意访问修饰符，因为它的地位就是一个成员

3.作用域：同其他的成员，为一整个整体

4.外部类访问 **静态内部类** 的方式：	创建对象，再访问

5.外部其他类访问 **静态内部类** 的方式：
-通过类名.静态内部类类名创建对象访问
-编写一个方法，可以返回静态内部类的对象实例

6.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用**（外部类名.成员）**去访问