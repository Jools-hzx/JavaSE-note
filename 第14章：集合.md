# 集合：

---



好处：

1.可以动态保存任意多个独享，使用比较方便
2.提供了一系列方便的操作对象的方法： add、 remove、set、get等
3.使用集合添加比较简洁

集合主要是两组（单列集合， 双列集合）
Collection 接口有两个重要的子接口 List Set, 他们的实现子类都是单列集合
Map 接口实现类子类，是双列集合



## Collection接口:

![](C:\Users\86136\Desktop\学习 & 工作\JAVA笔记\Image\微信截图_20220428174750.png)

---

## Map接口:

![](C:\Users\86136\Desktop\学习 & 工作\JAVA笔记\Image\微信截图_20220428174806.png)

---



### Collection中常用的方法：

```java
public class CollectionMethod {
    public static void main(String[] args) {
        List list = new ArrayList();
        
        //向列表中添加元素
        list.add("jack");
        list.add(10);
        list.add(true);
        System.out.println("list = " + list);

	   list.remove(0); //删除第一个元素
        list.remove("jack");    //指定删除某个元素
        System.out.println("list = " + list);
        
        //contain 查找元素是否存在
        System.out.println(list.contains("jack"));
        
        //判断大小 size
        System.out.println(list.size());
        
        //判断是否为空 isEmpty()
        System.out.println(list.isEmpty());
        
        //清空列表
        list.clear();
        System.out.println("list = " + list);
        	
        //addAll()添加多个元素
        ArrayList arrayList = new ArrayList();
        arrayList.add("a");
        arrayList.add("b");
        list.addAll(arrayList);
        System.out.println("list = " + list);
        
        //containAll：查找多个元素是否都存在
        System.out.println(list.containsAll(arrayList));
        
        //removeAll:删除多个元素
        list.add("聊斋");
        list.removeAll(arrayList);
        System.out.println("list = " + list);
    }
}
```

---

### 使用 Iterator 迭代器

1.主要用于遍历 Collection 集合的元素

2.所有实现了 Collection 接口的集合类都有一个iterator() 方法，用以返回一个实现了 iterator 接口的对象，即可以返回一个迭代器。

3.仅用于遍历集合，Iterator本身并不存放对象

```java
public class CollectionIterator {
    @SuppressWarnings({"all"})
    public static void main(String[] args) {

        Collection col = new ArrayList();
        col.add(new Book("三国演义", "罗贯中",10.1));
        col.add(new Book("小李飞刀", "古龙",13.1));
        col.add(new Book("红楼梦", "曹雪芹",8.1));
        //遍历
        //1.先实现迭代器
        Iterator iterator = col.iterator();
        //2.使用while循环
        //快捷键       itit 快速生成 迭代器
        //显示所有快捷键的快捷键
        while (iterator.hasNext()) {
            Object obj =  iterator.next();
            System.out.println("Object = " + obj);
        }
        //3.退出while循环后，这时这个迭代器指向了最后的元素
        iterator.next();    //报异常，NoSuchElement
        //如果希望再次遍历，需要重置迭代器
        iterator = col.iterator();
        System.out.println("第二次遍历====");
        while (iterator.hasNext()) {
            Object next =  iterator.next();
            System.out.println(next);
        }
        
    }
}

class Book {
    private String name;
    private String author;
    private double price;

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
```

---

### Collection接口遍历对象方式2 -- for循环增强

基本语法：

```java
public class CollectionFor {
    @SuppressWarnings({"all"})
    public static void main(String[] args) {
        Collection col = new ArrayList();
        col.add(new Book("三国演义", "罗贯中",10.1));
        col.add(new Book("小李飞刀", "古龙",13.1));
        col.add(new Book("红楼梦", "曹雪芹",8.1));

        //增强for
        //底层仍然是迭代器
        //就是简化版的迭代器遍历
        //快捷方式 I
        for (Object obj: col) {
            System.out.println("book = " + obj);
        }
        //增强for也可以在数组中使用
        int[] nums = {1, 2, 5, 6};
        for (int i: nums) {
            System.out.println("i = " + i);
        }
    }
}
```

---

## List 接口的常用方法

list接口时 Collection 接口的子接口
1.List 集合类中的元素有序（ 即添加顺序和取出顺序一致）、且可重复
2.List 集合中的每个元素都有其对应的顺序索引，即支持索引
3.List 容器中的元素都有对应一个整数型的序号记载在其容器中的位置，可以根据序号存取容器中的元素
4.JDK API中List接口的实现类有：ArrayList	Vector	LinkedList

```java
public class ListMethods {
    public static void main(String[] args) {

        List list = new ArrayList();
        list.add("张三丰");
        list.add("贾宝玉");
        //void list(int index, Object else)在index位置插入元素
        list.add(1,"hsp");
        System.out.println("list" + list);
        //addAll(int index, Collection else): 从index位置开始将else中的所有元素添加进来
        List list2 = new ArrayList();
        list2.add("jack");
        list2.add("tom");
        list.addAll(1, list2);
        System.out.println("list = " + list);
        //Object get(int index): 获取指定index位置的元素
        //indexOf(Object obj) 返回obj在集合位置中首次出现的位置
        System.out.println(list.indexOf("tom"));
        //lastIndexOf() 返回obj在集合位置中最后一次出现的位置
        //Object remove(int index): 移除指定index位置的元素，并返回此元素
        list.remove(0);
        //Object set(int index, Object ele):  设置指定index位置的元素为ele,相当于替换
        list.set(1, "玛丽");
        //List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合
        List returnList = list.subList(0, 2); //前闭后开
        System.out.println("returnList = " + returnList);
    }
}
```

---

## List的三种遍历方式

一：迭代器 iterator
二：使用增强for
三：使用普通for

```java
public class ListFor {
    @SuppressWarnings({"all"})
    public static void main(String[] args) {

        //List接口的实现子类 Vector LinkedList
        List list = new ArrayList();
        list.add("jack");
        list.add("tom");
        list.add("鱼香肉丝");
        list.add("北京烤鸭");

        //迭代器
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object obj =  iterator.next();
            System.out.println("list = " + obj);
        }

        //增强for
        for (Object o : list) {
            System.out.println("list = " + o);
        }

        //普通for
        for (int i = 0; i < list.size(); i++) {
            System.out.println("对象 =" + list.get(i));
        }
    }
}
```

---

练习：

基于冒泡算法对List进行排序

```java
public class ListExercise02 {
    @SuppressWarnings({"all"})
    public static void main(String[] args) {
        //List list = new ArrayList();		//用不同类实现
        //List list = new Vector();
        List list = new LinkedList();
        list.add(new Book("三国演义", 23, "罗贯中"));
        list.add(new Book("水浒传", 40, "无名氏"));
        list.add(new Book("红楼梦", 45, "曹雪芹"));
        //按价格排序
        list = BubbleSort(list);
        for (Object o :list) {
            System.out.println(o);
        }
    }
    public static List BubbleSort(List list) {  //静态冒泡算法，价格从小到大
        int listSize = list.size();
        for (int i = 0; i < listSize - 1; i++) {
            for (int j = 0; j < listSize - i - 1; j++) {
                //取出对象Book
                Book book1 = (Book) list.get(j);
                Book book2 = (Book) list.get(j + 1);
                if (book1.getPrice() > book2.getPrice()) {
                    list.set(j + 1, book1);		//设置新元素
                    list.set(j, book2);
                }
            }
        }
        return list;
    }
}

class Book {
    private String name;
    private double price;
    private String Author;

    public Book(String name, double price, String author) {
        this.name = name;
        this.price = price;
        Author = author;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public String getAuthor() {
        return Author;
    }

    public void setAuthor(String author) {
        Author = author;
    }

    @Override
    public String toString() {
        String format = "名称：%-5s  价格: %-4s  作者：%-4s \n";
        String formatString = String.format(format, name, price, Author);
        return formatString;
    }
}
```

---

## ArrayList注意事项

ArrayList 是线程不安全的， 可以看源码，没有 synchronized

多线程情况下不介意实现 ArrayList



### **底层操作机制源码：**

1.ArrayList中维护了一个Object类型的数组 elementData
**transient Object[ ]  elementData;	// 表示瞬间，短暂的，表示该属性不会被序列化**

2.当创建 ArrayList 对象时， 如果使用的是无参构造器，则初始 elementData 容量为 0， 第一次添加， 则扩容 elementData 为 10， 如需再次扩容，则扩容 elementData 为1.5倍

3.如果使用的是指定大小的构造器，则初始 elementData 容量为指定大小， 如需要扩容， 则直接扩容 elementData 为 1.5 倍



**无参构造器：**

```java
public ArrayList() {    //创建了一个空的Element数组
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

```java
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // 1.先确定是否要扩容
        elementData[size++] = e;		//2.然后再执行赋值的操作
        return true;
    }
```

```java
private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }

    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); //第一次扩容为10
    }
```

```java
private void ensureExplicitCapacity(int minCapacity) {
        modCount++;				//记录集合被修改的次数

        //如果elementData的大小不够，就调用grow()扩容
        if (minCapacity - elementData.length > 0)	
            grow(minCapacity);
    }
```

```java
    private void grow(int minCapacity) {	//真的扩容，使用扩容机制
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);	//向右移动一位，相当于除以二
        if (newCapacity - minCapacity < 0)			//第一次newCapacity为10
            newCapacity = minCapacity;				//第二次及其以后按照1.5倍扩容
        if (newCapacity - MAX_ARRAY_SIZE > 0)		
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity); //扩容使用的是 Array.copyOf()
    }
```

---

### 有参构造器

```java
public ArrayList(int initialCapacity) {	//创建一个指定大小elementData数组
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```

---



## Vector:

Vector底层也是一个对象数组， protected Object[ ]  elementData；

Vector 是线程同步的，即线程安全的。 Vector类的操作方法带有 synchronized

![](C:\Users\86136\Desktop\学习 & 工作\JAVA笔记\Image\ArrayList和Vector对比.png)

无参构造器

```java
public class Vector_ {
    public static void main(String[] args) {
        Vector vector = new Vector();
        for (int i = 0; i < 10; i++) {
            vector.add(i);
        }
        vector.add(100);
        System.out.println("vector = " + vector);
        /**
         * 1. new Vector()底层
         * public Vector() {
         *         this(10);
         *     }
         *补充：如果是有参构造器，那么走的方法就是
         * public Vector(int initialCapacity) {
         *         this(initalCapacity, 0);
         *     }
         * 2. add()
         * 2.1下面这个方法就是添加数据到Vector集合
         * public synchronized boolean add(E e) {
         *         modCount++;
         *         ensureCapacityHelper(elementCount + 1);
         *         elementData[elementCount++] = e;
         *         return true;
         *     }
         * ------------------------------------------    
         * 2.2是否需要扩容
         *  private void ensureCapacityHelper(int minCapacity) {
         *         // overflow-conscious code
         *         if (minCapacity - elementData.length > 0)
         *             grow(minCapacity);
         *     }
         * ------------------------------------------
         * 2.3  如果需要的数组大小不够了 就扩容
         * private void grow(int minCapacity) {
         *         // overflow-conscious code
         *         int oldCapacity = elementData.length;
         *         int newCapacity = oldCapacity + ((capacityIncrement > 0) ?   //扩容两倍
         *                                          capacityIncrement : oldCapacity);
         *         if (newCapacity - minCapacity < 0)
         *             newCapacity = minCapacity;
         *         if (newCapacity - MAX_ARRAY_SIZE > 0)
         *             newCapacity = hugeCapacity(minCapacity);
         *         elementData = Arrays.copyOf(elementData, newCapacity);
         *     }
         *     
         */
    }
}
```

---

## LinkedList 的底层机制：

1.LinkedList底层维护了一个双向链表

2.LinkedList 中维护了两个属性first 和 last 分别指向 首节点 和 尾节点

3.LinkedList 的元素 的 添加和删除，不是通过数组完成的，相对来说效率较高

4.每个节点（Node对象），里面又维护了 prev 、next、item三个属性，其中通过 prev 指向前一个，通过next指向最后一个节点。最终实现双向链表



### 一个简单的双向链表:

```java
public class LinkList01 {
    public static void main(String[] args) {

        //模拟一个简单的双向链表
        Node jack = new Node("Jack");
        Node tom = new Node("Tom");
        Node hsp = new Node("hsp");

        //连接三个节点，形成双向链表
        //jack -> tom -> hsp
        jack.next = tom;
        tom.next = hsp;
        //hsp -> tom -> jack
        hsp.pre = tom;
        tom.pre = jack;

        Node first = jack;  //让first 引用指向jack,就是双向链表的头节点
        Node last = hsp;    //让last 引用指向hsp,就是双向链表的尾节点。

        //演示链表添加数据
        //在tom 和 老韩之间 加入一个对象 smith
        //1.先创建一个Node 节点, smith
        Node smith = new Node("smith");
        //将smith 加入到双向链表
        smith.next = hsp;
        smith.pre = tom;
        hsp.pre = smith;
        tom.next = smith;

        //让first再次指向第一个
        first = jack;
        while (true) {  //演示，从头到尾进行遍历
            if (first == null) {
                break;
            }
            //输出 first 的信息
            System.out.println(first);
            first = first.next;
        }

        System.out.println("从尾到头进行遍历");
        while (true) {  //演示，从头到尾进行遍历
            if (last == null) {
                break;
            }
            //输出 first 的信息
            System.out.println(last);
            last = last.pre;
        }
    }
}

//定义一个Node类， 表示双向链表的一个节点
class Node {
    public Object item; //真正存放数据
    public Node next;    //指向下一个节点
    public Node pre;    //指向前一个节点
    public Node(Object name) {
        this.item = name;
    }

    @Override
    public String toString() {
        return "Node name = " + item;
    }
}
```



**LinkedList 的增删改查的案例：**

```java
public class LinkedListCRUD {
    public static void main(String[] args) {

        LinkedList linkedList = new LinkedList();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        System.out.println("LinkedList = " + linkedList);

        //删除节点
        linkedList.remove();    //默认删除第一个节点

        //修改节点
        linkedList.set(1, 999);
        System.out.println("linklist = " + linkedList);

        //得到某个节点
        //get(1) 是得到栓项链表的第二个对象
        Object o = linkedList.get(1);
        System.out.println(o);

        System.out.println("LinkedList = " + linkedList);
        /** 源码
         * 1. public LinkedList() {
         *     }
         * 2.这时 linkedList 的属性 first = null \ last = null
         * 3. 执行
         * public boolean add(E e) {
         *         linkLast(e);
         *         return true;
         *     }
         * 4.将新的节点加入到双向链表的最后
         * void linkLast(E e) {
         *         final Node<E> l = last;
         *         final Node<E> newNode = new Node<>(l, e, null);
         *         last = newNode;
         *         if (l == null)
         *             first = newNode;
         *         else
         *             l.next = newNode;
         *         size++;
         *         modCount++;
         *     }
         * --------------------
         * 删除：linkedList.remove();    //默认删除第一个节点
         * 1.public E remove() {
         *         return removeFirst();
         *     }
         * 2. 执行
         * public E removeFirst() {
         *         final Node<E> f = first;
         *         if (f == null)
         *             throw new NoSuchElementException();
         *         return unlinkFirst(f);
         *     }
         * 3.执行 unlinkFirst(f)    将第一个节点删除
         * private E unlinkFirst(Node<E> f) {
         *         // assert f == first && f != null;
         *         final E element = f.item;
         *         final Node<E> next = f.next;
         *         f.item = null;
         *         f.next = null; // help GC
         *         first = next;
         *         if (next == null)
         *             last = null;
         *         else
         *             next.prev = null;
         *         size--;
         *         modCount++;
         *         return element;
         *     }
         *
         */

        //因为Linkedlist 是 实现了 List 接口，遍历方式
        System.out.println("\n迭代器白遍历");
        Iterator iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            Object obj =  iterator.next();
            System.out.println("next = " + obj);
        }

        System.out.println("\n增强for循环");
        for (Object o1 :linkedList) {
            System.out.println("next_itmes = " + o1);
        }

        System.out.println("\n普通for循环");
        for (int i = 0; i < linkedList.size(); i++) {
            System.out.println(linkedList.get(i));
        }

    }
}
```

---

## 比较

![](C:\Users\86136\Desktop\学习 & 工作\JAVA笔记\Image\ArrayList和LinkedList比较.png)



---

## Set接口：

**1.无序（添加和取出的顺序不一样），没有索引**
**2.不允许重复的元素，所以最多包含一个null**

常用方法： 和Collention接口一样

**Set遍历方法：**
**和Collection的遍历方式一样，因为Set接口是Collection接口的子接口**
**1.可以使用迭代器**
**2.增强for**
**3.不能使用索引的方式来获取**



**基本方法**：

```java
@SuppressWarnings({"all"})
public class SetMethod {
    public static void main(String[] args) {
        //1. 以 Hashset 来讲解 set 接口的方法
        //2. set 接口的实现类的对象（ Set 接口对象），不能存放重复的元素，可以添加一个null
        //3. set 接口对象存放数据是无序的（即添加的顺序和取出的顺序不一致）
        //4.注意：取出的顺序是固定的，虽然不是添加的顺序，但是是固定的
        Set set = new HashSet();
        set.add("john");
        set.add("lucy");
        set.add("john");    //重复
        set.add("marry");
        set.add("jack");
        set.add(null);      //重复
        set.add(null);
        for (int i = 0; i < 10; i++) {
            System.out.println("set = " + set);

        }

        //遍历方式
        //1.迭代器
        System.out.println("===迭代器遍历===");
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object obj =  iterator.next();
            System.out.println("obj = " +obj);
        }

        set.remove(null);   //删除

        //增强for
        System.out.println("====增强for===");
        for (Object o : set) {
            System.out.println("o = " + o);
        }
        //不能使用索引来获取进行遍历
    }
}
```

---

### 其他说明：

```java
@SuppressWarnings({"all"})
public class HashSet01 {
    public static void main(String[] args) {
        HashSet set = new HashSet();

        //1. 在执行add 方法后
        //2. 如果添加成功，返回 true, 否则返回 false
        //3. 可以通过remove指定删除哪个对象
        System.out.println(set.add("john"));    //T
        System.out.println(set.add("lucy"));    //T
        System.out.println(set.add("john"));    //F
        System.out.println(set.add("jack"));    //T
        System.out.println(set.add("Rose"));    //T

        set.remove("john");
        System.out.println("set = " + set);
        //4. HashSet 不能添加相同的 元素 / 数据
        HashSet set1 = new HashSet();
        System.out.println("set1 = " + set1);
        set1.add("lucy");   //添加成功
        set1.add("lucy");   //加入不了
        set1.add(new Dog("tom"));
        set1.add(new Dog("tom"));
        System.out.println("set1 = " + set1);

        //经典面试题
        //去看源码，add()到底发生了什么
        set1.add(new String("hsp"));    //ok
        set1.add(new String("hsp"));    //加入不了
        System.out.println("set1 = " + set1);
    }
}

class Dog {     //定义一个 Dog 类
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
```



## **HashSet 底层结构说明** 

底层是，HashMap, 而HashMap底层是 （数组 + 链表 + 红黑树）

#### **代码简单实现：**

```java
@SuppressWarnings({"all"})
public class HashSetStructure {
    public static void main(String[] args) {
        //模拟一个HashMap的底层结构 (HashMap 底层结构）

        //1.创建一个数组,数组的类型是 Node[]
        //2. 有些人将 Node[] 称为 Table
        Node[] table = new Node[16];
        System.out.println("table = " + table);
        //创建节点
        Node john = new Node("john", null);
        table[2] = john;
        Node jack = new Node("jack", null);
        john.next = jack;   //将 jack 结点挂载到 john
        Node rose = new Node("Rose", null);
        jack.next = rose;   //将 rose 挂载到 jack
        Node lucy = new Node("Lucy", null);
        table[3] = lucy;    //将 lucy 放到 table 索引为 3 的位置
        System.out.println("table = " + table);
    }
}

class Node {    //节点，存储数据，可以指向下一个节点，从而形成链表
    Object item;
    Node next;  //指向下一个节点

    public Node(Object item, Node next) {
        this.item = item;
        this.next = next;
    }
}
```



## HashSet底层机制说明

1.HashSet 底层是 HashMap

2.添加一个元素，先得到hash值，	会转成 -> 索引值

3.找到存储数据表table， 看这个索引位置是否已经存放了 元素 / 数据

4.如果没有，直接加入

5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后

6.在Java8中，如果一条链表的元素个数到达/ TREEIFY_THRESHOLD(默认是8)，并且table的大小 >= MIN_TREEIFY_CAPACITY（默认64）就会进行树化（红黑树）

### 源码：

```java
@SuppressWarnings({"all"})
public class HashSetSource {
    public static void main(String[] args) {
        HashSet set = new HashSet();
        set.add("java");    //到此位置， 第一次add分析完毕
        set.add("php");  //到此位置， 第二次add分析完毕
        set.add("java");
        System.out.println("set = " + set);
        //源码解读：
        /** 1.执行 HashSet()
         *     public HashSet() {
         *         map = new HashMap<>();
         *     }
         * 2. 执行 add
         *      public boolean add(E e) {
         *         return map.put(e, PRESENT)==null;    //PRESENT = (static) PRESENT = new Object()
         *     }
         * 3. 再执行 put()方法, 该方法会执行 hash(key) 得到 key 对应的 hash 值   h = key.hashCode(() ^ (h >>> 16))
         *      public V put(K key, V value) {  //key = "java", value = PRESENT 共享
         *         return putVal(hash(key), key, value, false, true);
         *     }
         * 4. 执行 put（）value
         *  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
         *                    boolean evict) {
         *         Node<K,V>[] tab; Node<K,V> p; int n, i;      //定义了辅助变量
         *         //注：table  就是 HashMap 的一个数组，类型是 Node[]
         *         //   if 语句表示如果当前table 是 null， 或者 大小 = 0；
         *         //   就是第一次扩容，得到16个空间。
         *         if ((tab = table) == null || (n = tab.length) == 0)
         *             n = (tab = resize()).length;
         *         // 1.根据key, 得到hash, 去计算该 key 应该存放再table表的哪个索引位置
         *         //  并把这个位置的对象，赋给 p
         *         // 2.判断 p 是否为空
         *         // 2.1 如果 p 为空，表示还没有存放元素， 就创建一个 Node(key = "java", value = PRESENT)
         *         // 2.2 就放在该位置， tab[i] = newNode(hash, key, value, null);
         *         if ((p = tab[i = (n - 1) & hash]) == null)
         *             tab[i] = newNode(hash, key, value, null);
         *         else {
         *              //一个开发技巧提示：在需要局部变量（辅助）的时候，再创建
         *             Node<K,V> e; K k;
         *             // 如果当前索引位置对应的链表的第一个元素 和 准备添加的 key 和 hash 值一样
         *             // 并且满足下列两个条件之一：
         *             // 1. 准备加入的 key 和 p 指向的 Node 节点的 key 是同一个对象
         *             // 2. p 指向 Node 节点的 key 的 equals() 和 准备加入的 key 比较后相同
         *             // 就不能加入
         *             if (p.hash == hash &&
         *                 ((k = p.key) == key || (key != null && key.equals(k))))
         *                 e = p;
         *             // 再判断 p 是不是一颗 红黑树
         *             // 如果是一颗 红黑树， 就调用 putTreeVal, 来进行添加
         *             else if (p instanceof TreeNode)
         *                 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
         *             else {   //如果 table 对应的索引位置 已经是一个链表了，就使用 for 循环比较
         *                      //1.依次和该链表的每个元素比较后都不相同
         *                      // 注意在把该元素添加到链表后， 立即判断 给链表 是否已经 达到了 8 个节点
         *                      //  就调用 treeiftBin() 对当前这个链表进行树化（转成红黑树）
         *                      //  注意，在转成红黑树时，要进行判断，判断条件
         *                      //  if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY(64))
         *                      //       resize();
         *                      //  如果上面条件成立，先 table 扩容
         *                      //  只有上面条件不成立时，才进行转成红黑树
         *                      //2.依次比较的过程中，如果有相同的情况，就直接 break
         *                 for (int binCount = 0; ; ++binCount) {
         *                     if ((e = p.next) == null) {
         *                         p.next = newNode(hash, key, value, null);
         *                         if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
         *                             treeifyBin(tab, hash);
         *                         break;
         *                     }
         *                     if (e.hash == hash &&
         *                         ((k = e.key) == key || (key != null && key.equals(k))))
         *                         break;
         *                     p = e;
         *                 }
         *             }
         *             if (e != null) { // existing mapping for key
         *                 V oldValue = e.value;
         *                 if (!onlyIfAbsent || oldValue == null)
         *                     e.value = value;
         *                 afterNodeAccess(e);
         *                 return oldValue;
         *             }
         *         }
         *         ++modCount;
         //size 每加入一个结点 Node (k, v, h, next), size就会++
         *         if (++size > threshold)
         *             resize();
         *         afterNodeInsertion(evict);
         *         return null;
         *     }
         *
         */
    }
}
```



## HashSet 底层机制:

分析 **HashSet 扩容**和 **转成红黑树机制**

1.HashSet底层是HashMap，第一次添加时， table 数组扩容到 16, 临界值（threshold) 是 16 * 加载因子（loadFactor) 是 0.75  = 12;

2.如果table 数组使用到了临界值 12， 就会扩容到 16 * 2 = 32， 新的临界值就是 32 * 0.75 = 24, **以此类推**

3.在Java8中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)， 并且table的大小 >= MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树），否则仍然采用数组扩容机制

---

### 课堂练习：基于特定条件（员工姓名 + 员工生日日期）来判断是否能添加进 HashSet，若相同则不能加入:

```java
@SuppressWarnings({"all"})
public class HashSetExercise02 {
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();

        hashSet.add(new Employee01("jack", 23, new MyDate(2001, 01, 9)));
        hashSet.add(new Employee01("Tom", 23, new MyDate(2002, 01, 10)));
        hashSet.add(new Employee01("jack", 23, new MyDate(2001, 01, 9)));

        for (Object obj :hashSet) {
            System.out.println("员工：" + obj);
        }
    }
}

class Employee01 {
    private String name;
    private double salary;
    private MyDate mydate;		//自定义MyDate类型

    public Employee01(String name, double salary, MyDate mydate) {
        this.name = name;
        this.salary = salary;
        this.mydate = mydate;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public MyDate getMydate() {
        return mydate;
    }

    public void setMydate(MyDate mydate) {
        this.mydate = mydate;
    }

    @Override
    public String toString() {
        return "Employee01{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                ", mydate=" + mydate +
                '}';
    }

    @Override
    public boolean equals(Object o) {	//重写equals（）方法，基于名字和生日日期相比较
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee01 that = (Employee01) o;
        return Objects.equals(name, that.name) && Objects.equals(mydate, that.mydate);
    }

    @Override
    public int hashCode() {  //重写hashCode（）方法，基于名字和生日日期相比较
        return Objects.hash(name, mydate);
    }
}

class MyDate {
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }

    @Override
    public String toString() {
        return "Mydate{" +
                "year=" + year +
                ", month=" + month +
                ", day=" + day +
                '}';
    }

    @Override
    public boolean equals(Object o) {  //重写equals（）方法，基于三个不同属性相比较
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return year == myDate.year && month == myDate.month && day == myDate.day;
    }

    @Override
    public int hashCode() {   //重写hashCode（）方法，基于名字和生日日期相比较
        return Objects.hash(year, month, day);
    }
}
```

---



## LinkedHashSet (HashSet的子类)

LinkedHashSet 底层是一个 LinkHashMap，底层维护了一个 **数组 + 双向链表**

LinkedHashSet 根据元素的 hashCode 值来决定存储的位置，同时使用**链表维护元素的次序**，这使得元素看起来是以插入顺序保存的。

LinkedHashSet 不允许添加重复元素



### 说明：

---

1.在LinkedHashSet 中维护了一个hash表和双向链表

**2.每个节点有 pre 和 next 属性，这样可以形成双向链表**

3.在添加一个元素时，先求hash值，再求索引。确定该元素在 hashtable 的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加【原则和 hashset 一样】

```java
tail.next = newElement;	//简单指定
newElement.pre = tail;
tail = newElement;
```

**4.遍历 LinkedHashSet 也能确保插入顺序和遍历顺序一致**

### 源码分析

```java
@SuppressWarnings({"all"})
public class LinkedHashSetSource {
    public static void main(String[] args) {
        //分析一下 LinkedHashSet 的底层机制
        Set set = new LinkedHashSet();
        set.add(new String("AA"));
        set.add(456);
        set.add(456);
        set.add(new Consumer("刘", 1001));
        set.add(123);
        set.add("HSP");

        System.out.println("set =" + set);
        //1.LinkedHashSet 加入顺序 和 元素 / 数据 的顺序一致
        /**
         * 2.LinkedHashSet 底层维护的是一个 LinkedHashMap(是HashMap的子类)
         * 3.LinkedHashSet 底层结构 （数组 + 双向链表）
         * 4. 添加第一次时，直接将 table 扩容到 16，存放的结点类型是 LinkedHashMap$Entry
         * 5.数组是 HashMap$Node[] | 存放的元素 / 数据是 LinkedHashMap$Entry类型
         *
         *     static class Entry<K,V> extends HashMap.Node<K,V> {
         *         Entry<K,V> before, after;
         *         Entry(int hash, K key, V value, Node<K,V> next) {
         *             super(hash, key, value, next);
         *         }
         *     }
         */
    }
}

class Consumer {
    private String name;
    private int number;

    public Consumer(String name, int number) {
        this.name = name;
        this.number = number;
    }

    @Override
    public String toString() {
        return "Consumer{" +
                "name='" + name + '\'' +
                ", number=" + number +
                '}';
    }
}
```

---



## Map 接口：

### 接口特点：

```java
public class Map_ {
    public static void main(String[] args) {

        //Map接口实现类的特点
        //1.Map 与 Collection 并列存在。用于保存具有映射关系的数据：Key - Value (双列元素）
        //2.Map 中的 Key 和 value 可以是在任何时候引用类型的数据，会封装到 HashMap$Node 对象中
        //3.Map 中的 key 不允许重复，原因和 HashSet 一样，前面分析过源码
        //4.Map 中的 value 可以重复
        //5.Map 的 key 可以为 null，value 也可以为 null， 注意 key 为 null，只能有一个。 value 为 null,可以有多个
        //6.常用String类作为 Map的 key
        //7.key 和 value 之间存在单向一对一的关系，即通过指定的 key 总能找到对应的 value
        HashMap map = new HashMap();
        map.put("no1", "hsp");
        map.put("no2", "张无忌");  //k-v
        map.put("no1", "张三丰");  //当有相同的 k, 就等价于替换
        map.put("no3", "张无忌");
        map.put(null, null);
        map.put(null, "abc");   //替换
        map.put("no4", null);
        map.put("no5", null);
        map.put(new Object(), "金毛狮王");
        //通过 get 方法传入一个 key, 会返回对应的 value
        System.out.println(map.get("no2"));
        System.out.println("map = " + map);
    }
}
```

### 特点二

```java
public class MapSource {
    public static void main(String[] args) {

        HashMap map = new HashMap();
        map.put("no1", "hsp");
        map.put("no2", "张无忌");  //k-v
        map.put(new Car(), new Person());

        /**
         * 解读：
         * 1.k - v 最后是 HashMap$Node node = newNode(hash, key, value, null)
         * 2.k - v 为了方便程序员的遍历， 还会创建一个 EntrySet 集合， 该集合存放的元素的类型是 				Entry, 而一个 Entry
         *   对象就有 k,v EntrySet<Entry<K,V>>, 即: transient Set<Map.Entry<K,V>> entrySet;
         * 3.在EntrySet中，定义的类型是 Map.Entry, 实际上存放的还是 HashMap$Node
         *   这是因为 HashMap$Node implements Map.Entry
         * 4. 这样当把 HashMap$Node 对象 存放到 entrySet 就方便我们遍历, 因为 Map.Entry 提供了重要				的方法
         *      K getKey(); V getValue();
         */

        Set set = map.entrySet();
        System.out.println(set.getClass());     //HashMap$EntrySet
        for (Object obj : set) {
//            System.out.println(obj.getClass());   //HashMap$Node
            //为了从 HashMap$Node 取出 k -v
            //1. 先做一个向下转型
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + " -- " + entry.getValue());
        }

        Set set1 = map.keySet();
        System.out.println(set1.getClass());
        Collection values = map.values();
        System.out.println(values.getClass());
    }
}

class Car {}
class Person {}
```



## Map 接口和常用的方法

```java
@SuppressWarnings({"all"})
public class MapMethods {
    public static void main(String[] args) {
        //演示Map接口常用方法
        Map map = new HashMap();
        map.put("Jools", new Book("", 100));
        map.put("Jools", "Tom");
        map.put("Tim", "Marry");
        map.put("John", "Marry");
        map.put("Anna", null);
        map.put(null, "Marry");
        map.put("Jack", "Bob");

//        System.out.println("map = " + map);
        //1.remove：根据键删除映射
        map.remove(null);
        System.out.println(map);
        //get:根据建获取值
        Object value = map.get("Anna");
        System.out.println(value);
        //size:获取元素个数
        System.out.println("k - v = " + map.size());
        //isEmpty: p判断个数是否为0
        System.out.println(map.isEmpty());
        //clear:清除 k - v
        map.clear();
        System.out.println("map = " + map);
        //containKey: 查找键是否存在
        System.out.println(map.containsKey("Jack"));
    }
}
```



## Map接口的遍历方式:

```java
@SuppressWarnings({"all"})
public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("Jools", new Book("", 100));
        map.put("Jools", "Tom");
        map.put("Tim", "Marry");
        map.put("John", "Marry");
        map.put("Anna", null);
        map.put(null, "Marry");
        map.put("Jack", "Bob");

        //第一组： 先取出所有的 key， 通过key 取出对应的 Value
        Set keyset = map.keySet();
        //1.增强for
        System.out.println("----第一种方式----");
        for (Object key : keyset) {
            System.out.println(key + "-" + map.get(key));
        }
        //2.迭代器
        System.out.println("----第二种方式----");
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) {
            Object key =  iterator.next();
            System.out.println(key + "-" + map.get(key));
        }

        //第二组: 把所有的 values 取出
        Collection values = map.values();
        //这里可以用所有 Collection 使用的遍历方法
        //1.增强for
        System.out.println("---取出所有的value  增强for---");
        for (Object value : values) {
            System.out.println("value = " + value);
        }
        //2.迭代器
        System.out.println("---取出所有的value  迭代器---");
        Iterator iterator1 = values.iterator();
        while (iterator1.hasNext()) {
            Object value =  iterator1.next();
            System.out.println("value = " + value);
        }

        //第三组: 通过 EntrySet 来获取 k-v
        Set entrySet = map.entrySet();
        System.out.println("---使用EntrySet 的 for 增强----");
        //1.增强for
        for (Object entry : entrySet) {
            //将 entry(Object) 转成 Map.Entry (向下转型）
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + " - "+ m.getValue());
        }
        //迭代器
        System.out.println("---使用EntrySet 的 迭代器----");
        Iterator iterator2 = entrySet.iterator();
        while (iterator2.hasNext()) {
            Object entry =  iterator2.next();
            System.out.println(entry.getClass());    //HashMap$Node --> 实现 -> Map.Entry(方法：getKey, getValue)
            //向下转型(Object --> Entry)
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }

    }
}

```



### 例题练习

```java
@SuppressWarnings({"all"})
public class MapExercise {
    public static void main(String[] args) {
        Employee jack = new Employee("Jack", 12300, "1001");
        Employee tim = new Employee("Tim", 23111, "1002");
        Employee bob = new Employee("Bob", 34122, "1003");
        Map map = new HashMap();
        map.put(jack.getID(), jack);    //键 - 员工ID； 值:员工对象
        map.put(tim.getID(), tim);
        map.put(bob.getID(), bob);

        //三种遍历方式
        //第一组
        Set keySet = map.keySet();
        System.out.println("第一组：使用keySet集合遍历 键 取出对应的 值");
        System.out.println("----增强for循环----");
        for (Object key : keySet) {
            Employee employee = (Employee) map.get(key);
            compareSalary(employee);            //调用静态方法比较
        }
        //2.迭代器
        System.out.println("----迭代器----");
        Iterator iterator = keySet.iterator();
        while (iterator.hasNext()) {
            Object key =  iterator.next();
            Employee employee = (Employee) map.get(key);
            compareSalary(employee);
        }
        System.out.println("\n");

        //第二组
        Collection values = map.values();
        System.out.println("第二组：使用 实现 Collection 的values来遍历值");
        //增强for
        System.out.println("--------增强for循环--------");
        for (Object value : values) {
            Employee employee = (Employee) value;
            compareSalary(employee);
         }
        //迭代器
        System.out.println("--------迭代器--------");
        Iterator iterator1 = values.iterator();
        while (iterator1.hasNext()) {
            Employee employee = (Employee) iterator1.next();
            compareSalary(employee);
        }
        System.out.println("\n");

        //第三组：  EntrySet
        //1.增强for
        Set set = map.entrySet();
        System.out.println("使用Entry遍历其中的 Node 值");
        System.out.println("--------增强for循环--------");
        for (Object obj : set) {
            Map.Entry entry = (Map.Entry) obj;                  //Oject --> Entry
            Employee employee = (Employee) entry.getValue();    //Entry --> Employee
            compareSalary(employee);
        }
        //2.迭代器
        System.out.println("-------------迭代器-----------");
        Iterator iterator2 = set.iterator();
        while (iterator2.hasNext()) {
            Map.Entry entry =  (Map.Entry) iterator2.next();    //Object --> Entry
            Employee employee = (Employee) entry.getValue();    //Entry --> Employee
            compareSalary(employee);
        }
        System.out.println("\n");
    }
    public static void compareSalary(Employee employee) {   //静态方法 比较工资
        if (employee.getSalary() > 18000) {
            System.out.println(employee);
        }
    }
}

class Employee {
    private String name;
    private double salary;
    private String ID;

    public Employee(String name, double salary, String ID) {
        this.name = name;
        this.salary = salary;
        this.ID = ID;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getID() {
        return ID;
    }

    public void setID(String ID) {
        this.ID = ID;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                ", ID='" + ID + '\'' +
                '}';
    }
}
```



## Map接口实现类 hashMap

1.Map接口的常用实现类：HashMap 、 Hashtable 和 Properties

2.HashMap 是 Map 接口使用频率最高的实现类

3.HashMap 是以 key-val 对的方式来存储数据

4.key 不能重复，但是是值可以重复，允许使用null键和 null值

5.如果添加相同的 key, 则会覆盖原来的key - val，等同于修改。（key不会替换，val会替换）

6.与HashSet一样，不保证映射的顺序，因为底层是以 hash 表的方式来存储的

7.HashMap没有形成同步，因此是线程不安全的



## HashMap底层机制及源码剖析：

1.HashMap底层维护了Node类型的数组table,默认为null

2.当创建的对象时，将加载因子**（loadfactor)初始化为 0.75**

3.当添加 key - cal 时，通过 key 的哈希值得到 table 的索引。然后判断该索引处是否有元素。
	如果没有元素直接添加。如果该处有元素，继续判断该元素的 key 和准备加入的 key 是否相等。
	如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应的处理。如果添加时发现
	容量不够，则需要扩容。

4.第一次添加，则需要扩容 table 容量为 16， 临界值（threshold)为12 （16 * 0.75）

5.以后再扩容，则需要扩容table容量为原来的 2 倍，临界值为原来的 2 倍，即 24，以此类推

6.在Java8中，如果一条链表的元素个数超过 **TREEIFY_THRESHOLD (默认是8)**，并且 **table 的大小 >= MIN_THREEIFY_CAPACITY(默认64)**，就会进化成 **红黑树**



## 源码展示：

```java
public class HashMapSource1 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("java", 10);
        map.put("php", 10);
        map.put("java", 20);
        System.out.println("map = " + map);

        //源码解读
        /**
         * 1.执行构造器 new HashMap()
         *  加载初始化因子 loadfactor = 0.75;
         *  HashMap$Node[] table = null
         * 2.执行 put 会调用 hash 方法计算 hash 值 (h = key.hashCode()) ^ (h >>> 16)
         *     public V put(K key, V value) {
         *         return putVal(hash(key), key, value, false, true);
         *     }
         * 3.    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
         *                    boolean evict) {
         *         Node<K,V>[] tab; Node<K,V> p; int n, i;      //辅助变量
         *         //如果底层的 table 数组为 null，或者 length = 0， 就扩容到 16
         *         if ((tab = table) == null || (n = tab.length) == 0)
         *             n = (tab = resize()).length;
         *         //取出 hash 值 对应的 table的索引的位置 Node, 如果为 null, 就直接把加入的 k-v
         *         //创建成一个 Node,加入到该位置
         *         if ((p = tab[i = (n - 1) & hash]) == null)
         *             tab[i] = newNode(hash, key, value, null);
         *         else {
         *             Node<K,V> e; K k;    //辅助变量
         *              //如果table的索引位置的 key 的 hash值 和新的 key的 hash值相同，
         *              //并且满足（ table 现有的节点的 key 和准备添加 key 是同一对象 || equals返回为真）
         *              //就认为不能加入
         *             if (p.hash == hash &&   
         *                 ((k = p.key) == key || (key != null && key.equals(k))))
         *                 e = p;
         *             else if (p instanceof TreeNode) //如果当前 Table 已有的 Node 是红黑树， 就按照红黑树的方式处理 
         *                 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
         *             else {   //如果找到的节点，后面是链表，就循环比较
         *                 for (int binCount = 0; ; ++binCount) {   //死循环
         *                     if ((e = p.next) == null) {          //如果整个链表没有和它相同的（equals)，就加到该链表的最后
         *                         p.next = newNode(hash, key, value, null);
         *                         //加入后，判断当前链表的个数，是否已经达到 8 个了。
         *                         //如果达到 8 个,就调用 treeifyBin(tab, hash)，进行红黑树转化
         *                         if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st 判断一个链表是否已经达到了 8 个
         *                             treeifyBin(tab, hash);
         *                         break;
         *                     }
         *                     if (e.hash == hash &&   //如果在循环过程中发现有相同的，就不添加了，break，就只是替换 value
         *                         ((k = e.key) == key || (key != null && key.equals(k))))
         *                         break;
         *                     p = e;
         *                 }
         *             }
         *             if (e != null) { // existing mapping for key
         *                 V oldValue = e.value;
         *                 if (!onlyIfAbsent || oldValue == null)
         *                     e.value = value;     //替换 key 对应的 值
         *                 afterNodeAccess(e);
         *                 return oldValue;
         *             }
         *         }
         *         ++modCount;      //每增加一个 Node,就size++
         *         if (++size > threshold)   //如果size > 临界值，就扩容
         *             resize();
         *         afterNodeInsertion(evict);
         *         return null;
         *     }
         *    5.关于树化
         *    //如果 table 为 null, 或者大小还没有到 64， 暂时不树化，而是进行扩容
         *    //否则进行树化
         *    final void treeifyBin(Node<K,V>[] tab, int hash) {
         *         int n, index; Node<K,V> e;
         *         if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
         *             resize();
         */
    }
}
```

---



## Map接口实现类 - Hashtable

1.存放的元素是键值对：即 K - V

**2.hashTable的键和值都不能为 null**	否则会抛出（NullPointerException)

3.hashTable 使用方法基本上和 HashMap 一样

**4.hashTable是线程安全的， hashMap是线程不安全的**



HashTable 扩容机制

```java
@SuppressWarnings({"all"})
public class HashTableExercise {
    public static void main(String[] args) {
        Hashtable table = new Hashtable();
        table.put("john", 100);
//        table.put(null, 100);       //异常 NullPointerException
//        table.put("john", null);    //异常 NullPointerException
        table.put("lucy", 100);  //ok
        table.put("lic", 100);   //ok
        table.put("lic", 80);    //替换
        table.put("lic1", 80);   
        table.put("lic2", 80);   
        table.put("lic3", 80);   
        table.put("lic4", 80);  
        table.put("lic5", 80);  
        table.put("lic5", 80); 
        table.put("lic6", 80);  
        System.out.println(table);
        //简单说明一下 HashTable的底层
        //1.底层有数组 Hashtable$Entry[] 初始化大小为 11
        //2.threshold 8 = （11 * 0.75） 临界值
        //3.扩容：按照自己的扩容机制来进行即可，
        //4. 执行方法 addEntry(hash, key, value, index); 添加K - V 封装到 Entry
        //5.当   if (count >= threshold) 满足时，就进行扩容
        //  按照 int newCapacity = (oldCapacity << 1) + 1;
    }
}
```



## Hashtable 和 HashMap 对比

1.HashMap	线程不安全，	效率高，	允许null键和null值

2.Hashtable	线程安全		  效率较低	不允许null键和null值

---



## Map 接口实现类	Properties:

基本介绍和方法：

```java
@SuppressWarnings({"all"})
public class Properties_ {
    public static void main(String[] args) {
        Properties properties = new Properties();
        //1.Properties是继承了Hashtable
        //2.可以通过键值对 k-v 来存储数据，k和v都不能为null
        //增加
        properties.put("john", 100);    //k-v
//        properties.put(null, 100);
//        properties.put("john", null);
        properties.put("lucy", 100);
        properties.put("lic", 100);
        properties.put("lic", 88);//如果有相同的key，值也会被替换

        System.out.println("properties = " + properties);

        //通过key 获取对应的值
        System.out.println(properties.get("lic"));  //88
        //删除
        properties.remove("lic");
        System.out.println("properties = " + properties);
        //修改
        properties.put("john", "约翰");
        System.out.println("properties = " + properties);
    }
}
```

---



## 总结-开发中如何选择集合实现类

1.先判断存储的类型

2.一组对象【单例】：Collention接口

​	允许重复：List
​					增删多：LinkedList [底层维护了一个双向链表]
​					改查多：ArrayList [底层维护了 Object类型的 可变数组]

​	不允许重复：Set
​					无序： HashSet 【底层是 HashMap,维护了一个哈希表， 即（数组 + 链表 + 红黑树）】
​					排序：TreeSet
​					插入和去除顺序一致： LinkedHashSet [ 底层 LinkedHashMap],  维护数组 + 双向链表

3. 一组键值对：Map
   				键无序： HashMap [底层是： 哈希表 JDK 7: 数组 + 链表， JDK8: 数组 + 链表 + 红黑树]	
   				键排序：TreeMap
   				键插入和键取出顺序一致： LinkedHashMap
   				读取文件	Properties



## TreeSet源码解读：

```java
@SuppressWarnings({"all"})
public class TreeSet_ {
    public static void main(String[] args) {
        //1.当我们使用无参构造器创建TreeSet时，仍然是无序的
        //2.老师希望添加的元素，按照字符串大小来排序
        //3.使用TreeSet提供的构造器，可以传入一个比较器（匿名内部类）
        //  指定排序的规则
        //4. 源码
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //调用String的 compareTo方法，进行字符串大小比较
                return ((String)o2).compareTo((String) o1);     //若为0，则不能加入进去
                //则修改规则为比较字符串长度，长度相等即返回0，被视为相同字符串
                //retrun ((String)o2).length() - ((String)o1).length()
            }
        });
        //添加数据
        treeSet.add("jack");
        treeSet.add("tom");
        treeSet.add("sp");
        treeSet.add("a");
        treeSet.add("tom");
        System.out.println("TreeSet = " + treeSet);

        //1.构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap属性 this.comparator
        //    public TreeMap(Comparator<? super K> comparator) {
        //        this.comparator = comparator;
        //    }
        //2. 在调用 treeSet.add("tom"), 在底层会执行到
        //      if (cpr != null) {  //cpr就是匿名内部类
        //            do {
        //                parent = t;
        //                //动态绑定到我们的匿名内部类(对象）compare
        //                cmp = cpr.compare(key, t.key);
        //                if (cmp < 0)
        //                    t = t.left;
        //                else if (cmp > 0)
        //                    t = t.right;
        //                else      //如果相等，即返回0，这个Key就没有加入
        //                    return t.setValue(value);
        //            } while (t != null);
        //        }
    }
}
```



## TreeMap源码解读

```java
@SuppressWarnings({"all"})
public class TreeMap_ {
    public static void main(String[] args) {

        //使用默认的构造器创建一个TreeMap
        /*
           要求：按照传入的 k（String）的大小进行排序
         */
//        TreeMap treeMap = new TreeMap();
       TreeMap treeMap = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //按照传入的 k（String）的大小进行排序
//                return (((String) o2).compareTo((String) o1));
                //按照K（String）的长度大小进行排序
                return (((String) o1).length()) - (((String) o1)).length();
            }
        });
        treeMap.put("jack", "杰克");
        treeMap.put("tom", "汤姆");
        treeMap.put("kristina", "克瑞斯提诺");
        treeMap.put("smith", "史密斯");
        treeMap.put("hsp", "韩顺平");  //加入不了

        System.out.println("TreeMap = " + treeMap);
        //源码解读
        /*
            1.构造器，把传入的实现了 Comparator 接口的匿名内部类（对象),传给TreeMap 的 comparator
                public TreeMap(Comparator<? super K> comparator) {
                        this.comparator = comparator;
               }
            2.调用Put方法
            2.1 第一次添加元素
                if (t == null) {
                    compare(key, key); // type (and possibly null) check
            
                    root = new Entry<>(key, value, null);
                    size = 1;
                    modCount++;
                    return null;
                  }
            2.2  之后添加
            if (cpr != null) {
                do {        //遍历所有KEY,给当前key找到适当的位置
                    parent = t;
                    cmp = cpr.compare(key, t.key);  //动态绑定到我们的匿名内部类compare
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else  //如果遍历过程中，发现准备添加 KEY, 和当前已有的 Key 相等，就不添加了     
                        return t.setValue(value);
                } while (t != null);
            }     
         */
    }
}
```

---



## Collention工具类：

1.Collentions 是一个操作 Set、List 和 Map 的工具类
2.Collections 中提供了一系列静态的方法对集合元素进行排序，查询和修改等操作

**排序操作**

```java
public class Collections_ {
    public static void main(String[] args) {

        //创建一个ArrayList 集合用于测试
        List list = new ArrayList();
        list.add("tom");
        list.add("tom");
        list.add("smith");
        list.add("king");
        list.add("milan");
        //1.反转list中的元素
        Collections.reverse(list);
        System.out.println("list = " + list);
        //2.shuffle 对List 集合匀速进行随机的排序
//        for (int i = 0; i < 5; i++) {
//            Collections.shuffle(list);
//            System.out.println("list = " + list);
//        }
        //3.sort()： 根据元素的自然顺序对指定的 List 集合元素按升序进行排序
        Collections.sort(list);
        System.out.println("自然排序后 = " + list);
        //sort(List, Comparator):   根据指定的 Comparator 产生的顺序对 List集合元素 进行排序
        //按照字符串长度
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //可以加入一些校验代码
                return ((String)o1).length() - ((String) o2).length();
            }
        });
        System.out.println("字符串长度大小排序 = " + list);
        //swap  指定位置交换
        Collections.swap(list, 0, 1);
        System.out.println("交换后的情况 = " + list);
        //Object max()： 根据元素的自然顺序，返回给定集合中的最大元素
        System.out.println("自然顺序最大元素：" + Collections.max(list));
        //Object max(Collention, Comparator):根据 Comparator 指定的顺序，返回给定集合中的最大元素
        //比如返回长度最大的元素
        Object maxObject = Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        System.out.println("长度最大的元素 = " + maxObject);

        //Object min(Collection)
        //Object min(Collection, Comparator)
        //同 max 一致

        //int frequency(Collection, Object):    返回指定集合中指定元素的出现次数
        System.out.println("tom出现的次数=" + Collections.frequency(list, "tom"));   //2

        //void copy(List dest, List src) 将src的内容复制到dest中去
        List dest = new ArrayList();
        //为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size() 一样
        for (int i = 0; i < list.size(); i++) {
            dest.add("");
        }
        Collections.copy(dest, list);
        System.out.println("dest = " + dest);

        //replaceAll()  使用新值替换 List 对象的所有旧值
        //如果list中，有tom就替换成 汤姆
        Collections.replaceAll(list, "tom", "汤姆");
        System.out.println("list 替换后 = " + list);
    }
}
```



### 简答题：

试着分析HashSet 和 TreeSet 分别如何实现去重的

**1.HashSet的去重机制：**hashCode() + equals()， 底层先通过存入对象，进行运算的到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置没有数据，就直接存放对象；如果有元素，就进行equals（比较/遍历比较）（规则由程序员决定），如果比较后不相同，就加入；否则，不加入

**2.TreeSet去重机制：**如果你传入一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是相同的元素，就不添加；如果没有一个Comparator匿名对象，则以你添加的对象实现的Comparable接口的compareTo去重



### 例题

```java
//add 方法，因为TreeSet（）构造器没有传入Comparator接口的匿名内部类
//所有在底层 Comparable<? super K> k = (Comparable<? super K>) key;
//即把 Person转成 Comparable类型	若不实现或重写Comparable类的compareTo方法，则会报错
TreeSet treeSet = new TreeSet();
treeSet.add(new Person());
```

